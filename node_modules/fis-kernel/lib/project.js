/*
 * fis
 * http://web.baidu.com/
 */

'use strict';

var fis = require('../fis-kernel.js');
var tar, remote;

exports.DEFAULT_REMOTE_REPOS = 'http://web.baidu.com/fis_repos';
exports.DEFAULT_CONF_FILE = 'fis-conf.json';

exports.init = function(root, callback){
    
    if(fis.util.isDir(root)){
        //set root
        exports.setProjectRoot(root);
        
        //merge user conf
        var conf = fis.config.get('system.conf', exports.DEFAULT_CONF_FILE);
        if(fis.util.isFile(conf)){
            fis.config.merge(fis.util.readJSON(conf));
        }
        
        //undownloaded dependencies counter
        var count = 0;
        
        //download remote
        remote = fis.config.get('system.repos', exports.DEFAULT_REMOTE_REPOS).replace(/\/$/, '');
        
        //traverse dependencies
        fis.util.map(fis.config.get('deps', {}), function(name, version){
            var dir = exports.getLibPath(name, version, name);
            var flag = dir + '/.inited';
            if(!fis.util.exists(flag)){
                count++;
                var url = remote + '/' + name + '/' + version + '.tar';
                process.stdout.write('download module [' + name + '@' + version + '] ... ');
                fis.util.download(url, function(err, file){
                    if(err){
                        process.stdout.write('fail\n');
                        fis.log.error( 'unable to download modules [' +
                            name + '@' + version + '] from [' + url + '], error [' + err + ']');
                    } else {
                        tar = tar || require('tar');
                        fis.util.fs
                            .createReadStream(file)
                            .pipe(tar.Extract({
                                path : dir
                            }))
                            .on('error', function(err){
                                process.stdout.write('fail\n');
                                fis.log.error(err);
                            })
                            .on('end', function(){
                                process.stdout.write('ok\n');
                                var str = [
                                    'name : ' + name + '@' + version,
                                    'from : ' + url,
                                    'time : ' + (new Date)
                                ].join('\n');
                                fis.util.write(flag, str);
                                if(--count == 0){
                                    callback();
                                }
                            });
                    }
                });
            }
        });
        if(count == 0){
            callback();
        }
    } else {
        fis.log.error('invalid project root dir [' + root + ']');
    }
};

exports.getSource = function(opt){
    var root = exports.getProjectPath(),
        dirs = [root];
    fis.util.map(fis.config.get('deps', {}), function(name, version){
        var dir = exports.getLibPath(name, version, name);
        if(fis.util.isDir(dir)){
            dir = fis.util.realpath(dir);
            dirs.push(dir);
        } else {
            fis.log.error('unable to find dependency [' + name + '@' + version + ']');
        }
    });
    var source = {};
    opt = opt || {};
    dirs.forEach(function(path){
        fis.util.find(path, opt.include, opt.exclude).forEach(function(file){
            file = fis.file(file);
            source[file.subpath] = file;
        });
    });
    return source;
}

//paths
var PROJECT_ROOT;
var LIB_ROOT;
var TEMP_ROOT;

function getPath(root, args){
    if(args && args.length > 0){
        args = root + '/' + Array.prototype.join.call(args, '/');
        return fis.util(args);
    } else {
        return root;
    }
}

function initDir(path, title){
    if(fis.util.exists(path)){
        if(!fis.util.isDir(path)){
            fis.log.error('unable to set path[' + path + '] as ' + title + ' directory.');
        }
    } else {
        fis.util.mkdir(path);
    }
    path = fis.util.realpath(path);
    if(path){
        return path;
    } else {
        fis.log.error('unable to create dir [' + path + '] for ' + title + ' directory.');
    }
}

exports.getProjectPath = function(){
    if(PROJECT_ROOT){
        return getPath(PROJECT_ROOT, arguments);
    } else {
        fis.log.error('undefined project root');
    }
};

exports.setProjectRoot = function(path){
    if(fis.util.isDir(path)){
        PROJECT_ROOT = fis.util.realpath(path);
    } else {
        fis.log.error('invalid project root path [' + path + ']');
    }
};

exports.setTempRoot = function(tmp){
    TEMP_ROOT = initDir(tmp);
};

exports.getTempPath = function(){
    if(!TEMP_ROOT){
        this.setTempRoot(__dirname + '/../.tmp');
    }
    return getPath(TEMP_ROOT, arguments);
};

exports.setLibRoot = function(path){
    LIB_ROOT = initDir(path);
};

exports.getLibPath = function(){
    if(!LIB_ROOT){
        exports.setLibRoot(exports.getTempPath('fis_modules'));
    }
    return getPath(LIB_ROOT, arguments);
};

exports.getCachePath = function(){
    return getPath(TEMP_ROOT + '/cache', arguments);
};